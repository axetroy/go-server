// Code generated by easyjson but it's highly edited. Please manually add fields as Log is grow,
// in-short: all decode methods removed, rename of the methods, add a new line breaker,
// remove the easyjson import requirement.

package accesslog

import (
	"encoding/json"

	"github.com/kataras/iris/v12/core/memstore"
	"github.com/mailru/easyjson/jwriter"
)

func (f *JSON) writeEasyJSON(in *Log) error {
	out := &jwriter.Writer{NoEscapeHTML: !f.EscapeHTML}

	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"timestamp\":"
		if first {
			first = false
			out.RawString(prefix[1:])
		} else {
			out.RawString(prefix)
		}

		if f.HumanTime {
			t := in.Now.Format(in.TimeFormat)
			out.String(t)
		} else {
			out.Int64(in.Timestamp)
		}
	}
	{
		const prefix string = ",\"latency\":"
		out.RawString(prefix)
		out.Int64(int64(in.Latency))
	}
	{
		const prefix string = ",\"code\":"
		out.RawString(prefix)
		out.Int(int(in.Code))
	}
	{
		const prefix string = ",\"method\":"
		out.RawString(prefix)
		out.String(in.Method)
	}
	{
		const prefix string = ",\"path\":"
		out.RawString(prefix)
		out.String(in.Path)
	}
	if in.IP != "" {
		const prefix string = ",\"ip\":"
		out.RawString(prefix)
		out.String(in.IP)
	}
	if len(in.Query) != 0 {
		const prefix string = ",\"query\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v4, v5 := range in.Query {
				if v4 > 0 {
					out.RawByte(',')
				}
				easyJSONStringEntry(out, v5)
			}
			out.RawByte(']')
		}
	}
	if len(in.PathParams) != 0 {
		const prefix string = ",\"params\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v6, v7 := range in.PathParams {
				if v6 > 0 {
					out.RawByte(',')
				}
				easyJSONEntry(out, v7)
			}
			out.RawByte(']')
		}
	}
	if len(in.Fields) != 0 {
		const prefix string = ",\"fields\":"
		out.RawString(prefix)
		{
			out.RawByte('[')
			for v8, v9 := range in.Fields {
				if v8 > 0 {
					out.RawByte(',')
				}
				easyJSONEntry(out, v9)
			}
			out.RawByte(']')
		}
	}
	if in.Logger.RequestBody {
		const prefix string = ",\"request\":"
		out.RawString(prefix)
		out.String(string(in.Request))
	}
	if in.Logger.ResponseBody {

		const prefix string = ",\"response\":"
		out.RawString(prefix)
		out.String(string(in.Response))

	}
	if in.BytesReceived != 0 {
		const prefix string = ",\"bytes_received\":"
		out.RawString(prefix)
		out.Int(int(in.BytesReceived))
	}
	if in.BytesSent != 0 {
		const prefix string = ",\"bytes_sent\":"
		out.RawString(prefix)
		out.Int(int(in.BytesSent))
	}
	out.RawByte('}')
	out.RawByte(newLine)

	if out.Error != nil {
		return out.Error
	}
	f.ac.Write(out.Buffer.BuildBytes())
	return nil
}

func easyJSONEntry(out *jwriter.Writer, in memstore.Entry) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"key\":"
		out.RawString(prefix[1:])
		out.String(string(in.Key))
	}
	{
		const prefix string = ",\"value\":"
		out.RawString(prefix)
		if m, ok := in.ValueRaw.(json.Marshaler); ok {
			out.Raw(m.MarshalJSON())
		} else {
			out.Raw(json.Marshal(in.ValueRaw))
		}
	}
	out.RawByte('}')
}

func easyJSONStringEntry(out *jwriter.Writer, in memstore.StringEntry) {
	out.RawByte('{')
	first := true
	_ = first
	{
		const prefix string = ",\"key\":"
		out.RawString(prefix[1:])
		out.String(string(in.Key))
	}
	{
		const prefix string = ",\"value\":"
		out.RawString(prefix)
		out.String(string(in.Value))
	}
	out.RawByte('}')
}
